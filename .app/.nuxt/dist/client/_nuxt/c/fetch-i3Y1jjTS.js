import{aR as e,r as a,aS as t,aT as r,ar as s,aL as n,J as o,$ as i,aU as c,u,a8 as l,c as d,aV as f,a4 as p,aW as y,aX as h}from"../e/entry-8qgg5CL-.js";const m=e=>"defer"===e||!1===e;function g(...d){const f="string"==typeof d[d.length-1]?d.pop():void 0;"string"!=typeof d[0]&&d.unshift(f);let[p,y,h={}]=d;if("string"!=typeof p)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof y)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const g=i();h.server=h.server??!0,h.default=h.default??(()=>null),h.getCachedData=h.getCachedData??(()=>g.isHydrating?g.payload.data[p]:g.static.data[p]),h.lazy=h.lazy??!1,h.immediate=h.immediate??!0,h.deep=h.deep??e.deep,h.dedupe=h.dedupe??"cancel";const v=()=>![null,void 0].includes(h.getCachedData(p));if(!g._asyncData[p]||!h.immediate){g.payload._errors[p]??=null;const e=h.deep?a:t;g._asyncData[p]={data:e(h.getCachedData(p)??h.default()),pending:a(!v()),error:r(g.payload._errors,p),status:a("idle")}}const D={...g._asyncData[p]};D.refresh=D.execute=(e={})=>{if(g._asyncDataPromises[p]){if(m(e.dedupe??h.dedupe))return g._asyncDataPromises[p];g._asyncDataPromises[p].cancelled=!0}if((e._initial||g.isHydrating&&!1!==e._initial)&&v())return Promise.resolve(h.getCachedData(p));D.pending.value=!0,D.status.value="pending";const a=new Promise(((e,a)=>{try{e(y(g))}catch(t){a(t)}})).then((e=>{if(a.cancelled)return g._asyncDataPromises[p];let t=e;h.transform&&(t=h.transform(e)),h.pick&&(t=function(e,a){const t={};for(const r of a)t[r]=e[r];return t}(t,h.pick)),g.payload.data[p]=t,D.data.value=t,D.error.value=null,D.status.value="success"})).catch((e=>{if(a.cancelled)return g._asyncDataPromises[p];D.error.value=c(e),D.data.value=u(h.default()),D.status.value="error"})).finally((()=>{a.cancelled||(D.pending.value=!1,delete g._asyncDataPromises[p])}));return g._asyncDataPromises[p]=a,g._asyncDataPromises[p]};const _=()=>D.refresh({_initial:!0}),w=!1!==h.server&&g.payload.serverRendered;{const e=l();if(e&&!e._nuxtOnBeforeMountCbs){e._nuxtOnBeforeMountCbs=[];const a=e._nuxtOnBeforeMountCbs;e&&(s((()=>{a.forEach((e=>{e()})),a.splice(0,a.length)})),n((()=>a.splice(0,a.length))))}w&&g.isHydrating&&(D.error.value||v())?(D.pending.value=!1,D.status.value=D.error.value?"error":"success"):e&&(g.payload.serverRendered&&g.isHydrating||h.lazy)&&h.immediate?e._nuxtOnBeforeMountCbs.push(_):h.immediate&&_(),h.watch&&o(h.watch,(()=>D.refresh()));const a=g.hook("app:data:refresh",(async e=>{e&&!e.includes(p)||await D.refresh()}));e&&n(a)}const b=Promise.resolve(g._asyncDataPromises[p]).then((()=>D));return Object.assign(b,D),b}function v(e,a,t){const[r={},s]="string"==typeof a?[{},a]:[a,t],n=d((()=>{let a=e;return"function"==typeof a&&(a=a()),h(a)})),o=r.key||f([s,"string"==typeof n.value?n.value:"",...D(r)]);if(!o||"string"!=typeof o)throw new TypeError("[nuxt] [useFetch] key must be a string: "+o);if(!e)throw new Error("[nuxt] [useFetch] request is missing.");const i=o===s?"$f"+o:o;if(!r.baseURL&&"string"==typeof n.value&&"/"===n.value[0]&&"/"===n.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:c,lazy:u,default:l,transform:m,pick:v,watch:_,immediate:w,getCachedData:b,deep:C,...P}=r,x=p({...y,...P,cache:"boolean"==typeof r.cache?void 0:r.cache});let k;return g(i,(()=>{k?.abort?.(),k="undefined"!=typeof AbortController?new AbortController:{};const e=h(r.timeout);return e&&setTimeout((()=>k.abort()),e),(r.$fetch||globalThis.$fetch)(n.value,{signal:k.signal,...x})}),{server:c,lazy:u,default:l,transform:m,pick:v,immediate:w,getCachedData:b,deep:C,watch:!1===_?[]:[x,n,..._||[]]})}function D(e){const a=[h(e.method)?.toUpperCase()||"GET",h(e.baseURL)];for(const t of[e.params||e.query]){const e=h(t);if(!e)continue;const r={};for(const[a,t]of Object.entries(e))r[h(a)]=h(t);a.push(r)}return a}export{v as u};
